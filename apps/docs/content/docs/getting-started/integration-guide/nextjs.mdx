---
title: Next.js
description: Step-by-step guide to integrating OptStuff image optimization into a Next.js application using server-side URL signing, with examples for a signing utility, Server Component, API Route, and next/image with unoptimized pre-signed URLs.
---

This guide shows how to integrate OptStuff into a Next.js application using the App Router.

For the security principles that apply to all integrations, see the [Integration Guide overview](/getting-started/integration-guide).

## Environment Variables

Add to your `.env.local`:

```bash
# Server-side only — secret! Never use the NEXT_PUBLIC_ prefix
OPTSTUFF_SECRET_KEY="sk_your_secret_key_here"

# Server-side only — not secret, but no need for NEXT_PUBLIC_ prefix
# The publicKey appears in generated URLs (?key=pk_...) and is not a secret
OPTSTUFF_PUBLIC_KEY="pk_abc123..."

# Public configuration
NEXT_PUBLIC_OPTSTUFF_PROJECT_SLUG="your-project-slug"
NEXT_PUBLIC_OPTSTUFF_ENDPOINT="https://your-optstuff-deployment.com/api/v1"
```

## Create a Signing Utility

Create `lib/optstuff.ts` (server-side only):

```typescript
import crypto from "crypto";

const SECRET_KEY = process.env.OPTSTUFF_SECRET_KEY!;
const PUBLIC_KEY = process.env.OPTSTUFF_PUBLIC_KEY!;
const ENDPOINT = process.env.NEXT_PUBLIC_OPTSTUFF_ENDPOINT!;
const PROJECT_SLUG = process.env.NEXT_PUBLIC_OPTSTUFF_PROJECT_SLUG!;

/**
 * Generates a signed image optimization URL.
 *
 * @param imagePath - Source image path (e.g., "images.example.com/photo.jpg")
 * @param operations - Image operations (e.g., "w_800,f_webp")
 * @param expiresIn - Signature validity in seconds (optional)
 *
 * @example
 * signImageUrl("cdn.example.com/photo.jpg", "w_800,f_webp")
 *
 * @example
 * signImageUrl("cdn.example.com/photo.jpg", "w_800", 3600) // expires in 1 hour
 */
export function signImageUrl(
  imagePath: string,
  operations: string = "_",
  expiresIn?: number
): string {
  const path = `${operations}/${imagePath}`;

  const exp = expiresIn
    ? Math.floor(Date.now() / 1000) + expiresIn
    : undefined;

  const payload = exp ? `${path}?exp=${exp}` : path;
  const sig = crypto
    .createHmac("sha256", SECRET_KEY)
    .update(payload)
    .digest("base64url")
    .substring(0, 32);

  let url = `${ENDPOINT}/${PROJECT_SLUG}/${path}?key=${PUBLIC_KEY}&sig=${sig}`;
  if (exp) url += `&exp=${exp}`;

  return url;
}
```

## Usage in Next.js

### Option 1: Server Component (Recommended)

The simplest approach — signing happens during server-side rendering:

```tsx
import { signImageUrl } from "@/lib/optstuff";

export default function HomePage() {
  const heroImage = signImageUrl(
    "cdn.example.com/hero.jpg",
    "w_1200,f_webp",
    86400 // 24 hours
  );

  return (
    <main>
      <img src={heroImage} alt="Hero" width={1200} height={600} />
    </main>
  );
}
```

### Option 2: API Route + Client Component

For client components that need to load images dynamically, create an API route to handle signing:

```typescript
// app/api/image-url/route.ts
import { signImageUrl } from "@/lib/optstuff";
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const src = searchParams.get("src");
  const width = searchParams.get("w");
  const height = searchParams.get("h");
  const format = searchParams.get("f") || "webp";

  if (!src) {
    return NextResponse.json(
      { error: "Missing src parameter" },
      { status: 400 }
    );
  }

  const ops = [
    width && `w_${width}`,
    height && `h_${height}`,
    `f_${format}`,
  ].filter(Boolean).join(",");

  const signedUrl = signImageUrl(src, ops, 3600);

  return NextResponse.json({ url: signedUrl });
}
```

Call it from a client component:

```tsx
"use client";

import { useState, useEffect } from "react";

type OptimizedImageProps = {
  readonly src: string;
  readonly width?: number;
  readonly alt: string;
};

export function OptimizedImage({ src, width, alt }: OptimizedImageProps) {
  const [imageUrl, setImageUrl] = useState<string>("");

  useEffect(() => {
    const fetchUrl = async () => {
      const params = new URLSearchParams({ src });
      if (width) params.set("w", width.toString());

      const res = await fetch(`/api/image-url?${params}`);
      const { url } = await res.json();
      setImageUrl(url);
    };

    fetchUrl();
  }, [src, width]);

  if (!imageUrl) return <div>Loading...</div>;

  return <img src={imageUrl} alt={alt} width={width} />;
}
```

### Option 3: Server Component with `next/image`

You can use `next/image` with OptStuff while keeping all signing server-side.
Sign the URL in a Server Component, then pass the signed URL as `src` with
`unoptimized` so Next.js won't re-optimize the already-optimized image.
You still get `next/image` benefits like lazy loading, layout shift prevention,
and responsive sizing.

```tsx
import Image from "next/image";
import { signImageUrl } from "@/lib/optstuff";

export function Hero() {
  const heroSrc = signImageUrl(
    "cdn.example.com/hero.jpg",
    "w_1200,f_webp",
    86400 // 24 hours
  );

  return (
    <Image
      src={heroSrc}
      alt="Hero"
      width={1200}
      height={630}
      unoptimized
    />
  );
}
```

<Callout type="warn">
Do **not** pass `signImageUrl` (or any function that uses your secret key) as a
`loader` prop to `next/image`. The `loader` function runs client-side, which
would expose `OPTSTUFF_SECRET_KEY` and fail because Node.js `crypto` is
unavailable in the browser. Always sign URLs on the server and pass the result
as a plain string `src`.
</Callout>

For more details on CDN caching with `next/image`, see the [CDN and Caching guide](/guides/cdn-caching#using-with-nextimage).

## Pre-Launch Checklist

Before going to production, verify:

- [ ] `secretKey` (`sk_...`) is in an environment variable **without** `NEXT_PUBLIC_` prefix
- [ ] `publicKey` (`pk_...`) is also in an environment variable for easy management
- [ ] `.env.local` file is in `.gitignore`
- [ ] Signing logic runs only in Server Components or API Routes
- [ ] No frontend code references the `secretKey`
- [ ] Appropriate `exp` expiration is set for signed URLs
- [ ] Domain whitelists are configured in the dashboard

## Troubleshooting

| Error | Likely Cause | Solution |
|-------|-------------|----------|
| `403` Invalid signature | Wrong key, wrong path order, or wrong encoding | See [Troubleshooting Signature Errors](/api-reference/error-codes#troubleshooting-signature-errors) |
| `403` Source domain not allowed | Image origin not in key's allowed domains | Add the domain in Dashboard → API Key settings |
| `403` Invalid referer | Your website not in project's allowed domains | Add the domain in Dashboard → Project settings |

For the complete error reference, see [Error Codes](/api-reference/error-codes).

## Further Reading

- [TypeScript / Node.js Integration](/getting-started/integration-guide/typescript) — For Express, Fastify, or standalone Node.js applications
- [URL Signing](/guides/url-signing) — Signature formula and security properties
- [Domain Whitelisting](/guides/domain-whitelisting) — Configure allowed domains
- [CDN and Caching](/guides/cdn-caching) — CDN integration and `next/image` best practices
- [Security Best Practices](/guides/security-best-practices) — Recommendations for production
