# 設計決策說明

本文件解釋各項安全設計背後的「為什麼」，幫助理解每個決策的目的。

## 為什麼要加密存儲 API Key？

```
問題: 如果資料庫被入侵，明文存儲的 API Key 會立即洩露
```

### 明文存儲 vs 加密存儲

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 情境: 資料庫遭到入侵                                                    │
└─────────────────────────────────────────────────────────────────────────┘

明文存儲:
┌──────────────┐     攻擊者入侵     ┌──────────────┐
│   Database   │ ────────────────→ │ 取得明文 Key │ → 立即可用於攻擊
│ pk_abc123... │                   │ sk_xyz789... │
└──────────────┘                   └──────────────┘

加密存儲:
┌──────────────┐     攻擊者入侵     ┌──────────────┐     需要額外取得
│   Database   │ ────────────────→ │ 取得密文     │ ──→ 環境變數密鑰
│ iv:tag:cipher│                   │ (無法使用)   │     才能解密
└──────────────┘                   └──────────────┘
                                          ↓
                                   攻擊難度大幅提升
```

### 設計決策

加密存儲提供「縱深防禦」，即使資料庫洩露，攻擊者還需要取得環境變數中的加密密鑰才能解密。

## 為什麼需要 URL 簽名？

```
問題: 如何防止未授權的人使用你的圖片優化服務？
```

### 沒有簽名的問題

```
任何人都可以:
1. 猜測或觀察你的 API endpoint
2. 免費使用你的服務處理他們的圖片
3. 消耗你的伺服器資源和頻寬
4. 產生費用由你承擔
```

### 簽名如何解決

```
請求: /api/v1/my-blog/w_800/images.com/photo.jpg?key=pk_xxx&sig=abc123

伺服器驗證流程:
1. 用 keyPrefix 查詢對應的 secretKey
2. 用 secretKey 重新計算簽名: expectedSig = HMAC(secretKey, path)
3. 比對 sig === expectedSig
4. 不匹配 → 拒絕請求

為什麼有效？
- secretKey 只有你知道
- 沒有 secretKey 就無法產生有效簽名
- 簽名是單向的，無法從 sig 反推 secretKey
```

### 設計決策

簽名證明「請求者確實擁有 secretKey」，沒有 secretKey 的人無法偽造有效請求。

## 為什麼用 HKDF 而不是簡單 Hash？

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 比較: SHA-256 Hash vs HKDF                                              │
└─────────────────────────────────────────────────────────────────────────┘

方法 1: 簡單 Hash (不推薦)
┌─────────────────┐
│ SHA256(secret)  │ → 單一密鑰
└─────────────────┘

問題:
- 無法安全派生多個密鑰
- 沒有版本控制機制
- 用途不明確

方法 2: HKDF (推薦)
┌─────────────────────────────────────────────────────────────────────────┐
│ HKDF(secret, salt="v1", info="encryption") → 加密密鑰                  │
│ HKDF(secret, salt="v1", info="signing")    → 簽名密鑰 (未來擴展)       │
│ HKDF(secret, salt="v2", info="encryption") → 新版加密密鑰 (key rotation)│
└─────────────────────────────────────────────────────────────────────────┘
```

### 優勢比較

| 特性 | 簡單 Hash | HKDF |
|------|----------|------|
| 派生多個密鑰 | ❌ 不安全 | ✅ 安全 |
| 版本控制 | ❌ 無 | ✅ Salt 版本化 |
| 用途區分 | ❌ 無 | ✅ Info 參數 |
| 標準化 | ❌ 無 | ✅ RFC 5869 |
| Key Rotation | ❌ 困難 | ✅ 容易 |

### 設計決策

HKDF 提供標準化、可擴展、可維護的密鑰派生方式，為未來的擴展預留空間。

## 為什麼要分離 keyPrefix 和 keyFull？

```
問題: 如何快速查詢 API Key，又不暴露完整密鑰？
```

### 設計架構

```
┌────────────────────────────────────────────────────────────────────────┐
│ keyFull:    pk_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6   │
│                  ↑                                                      │
│             加密存儲                                                    │
│                                                                         │
│ keyPrefix:  pk_a1b2c3d4                                                │
│                  ↑                                                      │
│             明文存儲 (用於快速查詢和 UI 顯示)                           │
└────────────────────────────────────────────────────────────────────────┘
```

### 為什麼這樣設計？

| 目的 | 說明 |
|------|------|
| 查詢效率 | 用 keyPrefix 建索引，O(1) 查詢，不需要解密所有 keyFull 來比對 |
| 安全性 | keyPrefix 太短無法用於驗證（只有 8 字元），真正的驗證靠 secretKey + 簽名 |
| 用戶體驗 | Dashboard 可以顯示 "pk_a1b2c3d4..."，用戶可以識別不同的 Key |

### 設計決策

分離查詢用途（keyPrefix）和敏感資料（keyFull、secretKey），兼顧效率和安全。

## 為什麼要有兩層 Domain 白名單？

```
兩層白名單解決不同的問題
```

### Layer 1: Project 級 - allowedRefererDomains

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 問題: 誰可以「使用」這個服務？                                          │
│ 驗證: HTTP Referer header                                               │
│ 用途: 防止其他網站嵌入你的圖片（盜連）                                  │
│                                                                          │
│ 例: 只允許 myblog.com 和 *.myblog.com 使用                             │
└─────────────────────────────────────────────────────────────────────────┘
```

### Layer 2: API Key 級 - allowedSourceDomains

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 問題: 可以處理「哪些來源」的圖片？                                      │
│ 驗證: 請求中的圖片 URL                                                  │
│ 用途: 限制可處理的圖片來源，防止被用來處理任意圖片                      │
│                                                                          │
│ 例: 只允許處理來自 cdn.myblog.com 的圖片                               │
└─────────────────────────────────────────────────────────────────────────┘
```

### 為什麼需要兩層？

```
場景: 你有多個網站，每個網站使用不同的圖片 CDN

┌─────────────────────────────────────────────────────────────────────────┐
│ Project: my-company                                                     │
│ allowedRefererDomains: [site-a.com, site-b.com, site-c.com]            │
│                                                                          │
│ API Key 1 (給 site-a.com):                                             │
│   allowedSourceDomains: [cdn.site-a.com]                               │
│                                                                          │
│ API Key 2 (給 site-b.com):                                             │
│   allowedSourceDomains: [images.site-b.com, s3.amazonaws.com]          │
│                                                                          │
│ API Key 3 (管理員測試用):                                              │
│   allowedSourceDomains: [*]  ← 允許所有來源                            │
└─────────────────────────────────────────────────────────────────────────┘
```

### 設計決策

兩層白名單提供細粒度控制：
- **Project 級**控制「誰可以用」
- **API Key 級**控制「可以處理什麼」

## 延伸閱讀

- [系統架構](./architecture.md) - 整體設計概覽
- [資料加密機制](./encryption.md) - 加密實作細節
- [安全最佳實踐](./security-best-practices.md) - 實際應用建議
